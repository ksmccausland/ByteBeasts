import runloop, motor_pair, motor, color, color_sensor, time
from hub import light, motion_sensor, port, sound, button, light_matrix

WHEEL_DIAMETER = 6.24    # wheel diameter in CM (6.24cm)

# define drive motors and PAIR_1
LEFT_DRIVE = port.C
RIGHT_DRIVE = port.A
LEFT_ATTACH = port.B
RIGHT_ATTACH = port.F
COLOR_SENSOR = port.E

motor_pair.pair(motor_pair.PAIR_1, LEFT_DRIVE, RIGHT_DRIVE)
DRIVE_PAIR = motor_pair.PAIR_1

# Turn robot by amount target_angle in degrees via a PID (proportional, integral, derivative).You WILL need to adjust kp, ki, and kd for different robots
# based on your wheel choice, robot's weight, attachments, etc. max_speed and acceleration will limit robot drive parameters.
async def pid_turn(target_angle, *, max_speed=1000, min_speed=50, acceleration=500, kp=1.5, ki=1, kd=1, accuracy=3, beep=True, troubleshoot=False):
    # pause for 0.3sec before running
    runloop.sleep_ms(300)

    # target_angle is in degrees, convert to decidegrees
    target_angle *= 10

    motion_sensor.reset_yaw(0)

    integral = 0
    last_error = 0
    dt = 0.01            # 10 ms
    max_integral = 10000# tweak as needed

    while True:
        current_angle = motion_sensor.tilt_angles()[0]# decidegrees
        error = target_angle - current_angle

        # Wrap error into [-1800, 1800] decidegrees
        if error > 1800:
            error -= 3600
        elif error < -1800:
            error += 3600

        # Stop when close enough (accuracy also in decidegrees)
        if abs(error) < accuracy:
            break

        # Derivative uses previous error
        derivative = (error - last_error) / dt

        # Correction uses *old* integral
        correction = kp * error + ki * integral + kd * derivative

        # Now update integral (after using it)
        integral += error * dt
        integral = max(-max_integral, min(max_integral, integral))

        last_error = error

        if troubleshoot:
            print("ang:",current_angle,"err:", error, "corr:", correction, "int:", integral, "d:", derivative)

        # Clamp correction
        correction = max(-max_speed, min(max_speed, correction))

        # Enforce minimum speed
        if abs(correction) < min_speed:
            correction = min_speed * (1 if correction >= 0 else -1)

        motor_pair.move_tank(DRIVE_PAIR, -int(correction), int(correction),
                            acceleration=acceleration)

        await runloop.sleep_ms(10)

    motor_pair.stop(DRIVE_PAIR, stop=motor.SMART_BRAKE)

    if beep:
        sound.beep(1000)

# Turn the robot by a given number of degrees using only one wheel.
# angle_deg > 0 = turn one direction
# angle_deg < 0 = turn the opposite direction
# drive_wheel    = "left" or "right"
async def pivot_turn(
        angle_deg,
        drive_wheel="l",
        *,
        speed=300,
        accuracy=2,
        beep=True,
        timeout=5000    # <-- new parameter in ms (0 = no timeout)
    ):

    # If no turn requested, just exit
    if angle_deg == 0:
        return

    # Choose which motor port to use
    if drive_wheel.lower() == "l":
        motor_port = LEFT_DRIVE
    else:
        motor_port = RIGHT_DRIVE

    # Reset yaw to 0 so we measure turn from here
    motion_sensor.reset_yaw(0)

    target_deg = angle_deg
    direction = 1 if target_deg > 0 else -1

    # Start the chosen wheel turning
    motor.run(motor_port, speed * direction)

    # Track starting time
    start_ms = time.ticks_ms()

    while True:

        # ---- TIMEOUT CHECK ----
        if timeout > 0:
            if time.ticks_diff(time.ticks_ms(), start_ms) >= timeout:
                # Timeout reached — exit loop
                break

        # SPIKE 3 motion_sensor.tilt_angles()[0] returns decidegrees → convert to degrees
        current_deg = motion_sensor.tilt_angles()[0] / 10
        error = target_deg - current_deg

        # Stop when within the desired accuracy
        if abs(error) <= accuracy:
            break

        await runloop.sleep_ms(10)

    # Stop the turning wheel
    motor.stop(motor_port, stop=motor.SMART_BRAKE)

    if beep:
        sound.beep(2000)

# distance (cm), speed (deg/s). Positive distance = forward.
# accel/decel are distances (as a fraction of total) over which to ramp.
async def drive_straight(distance, speed, *, beep=True, accel=0.25, decel=0.25, end=motor.HOLD, reset=True):
    # pause for 0.3sec before running
    runloop.sleep_ms(300)

    # direction/sign
    direction = -1 if distance >= 0 else 1
    max_speed = abs(int(speed))

    # convert cm -> wheel degrees
    target_degrees = abs(distance) * 360 / (WHEEL_DIAMETER * 3.14)
    accel_dist = target_degrees * max(0.0, min(0.9, accel))# clamp 0..0.9
    decel_dist = target_degrees * max(0.0, min(0.9, decel))

    # encoder & yaw reset
    motor.reset_relative_position(LEFT_DRIVE, 0)
    motor.reset_relative_position(RIGHT_DRIVE, 0)

    if reset == True:
        motion_sensor.reset_yaw(0)

    # wait until robot motion is stable (optional)
    # await runloop.until(motion_sensor.stable)

    def progress_deg():
        a = abs(motor.relative_position(LEFT_DRIVE))
        b = abs(motor.relative_position(RIGHT_DRIVE))
        return (a + b) / 2# <-- true average progress

    avg_deg = progress_deg()

    # give it some initial nudge to overcome static friction
    v_min = max(80, int(0.12 * max_speed))# 12% of max or 80 deg/s, whichever is higher

    while avg_deg < target_degrees:
        # heading correction from gyro (yaw)
        error = motion_sensor.tilt_angles()[0]
        correction = int(error * -2)

        remaining = max(0.0, target_degrees - avg_deg)

        # trapezoid profile factor in [0..1]
        accel_factor = 1.0 if accel_dist <= 1e-6 else (avg_deg / accel_dist)
        decel_factor = 1.0 if decel_dist <= 1e-6 else (remaining / decel_dist)
        shape = min(1.0, accel_factor, decel_factor)

        # target speed with floor (v_min)
        target_speed = int(v_min + (max_speed - v_min) * shape)

        # apply direction (Spike Prime uses positive=one direction; your code used -*)
        # Keep your sign convention: multiply by direction and -1 as before.
        cmd = target_speed * direction * -1

        motor_pair.move_tank(DRIVE_PAIR, cmd - correction, cmd + correction)

        # update progress
        avg_deg = progress_deg()

    motor_pair.stop(DRIVE_PAIR, stop=end)

    if beep:
        sound.beep(500)

# --- Define your functions for each color ---
async def action_azure():
    print("Running AZURE function")
    deploy = 15

    await drive_straight(64,1000, beep=True)
    await motor.run_for_degrees(RIGHT_ATTACH,90*deploy,600)
    await runloop.sleep_ms(500)
    await drive_straight(-7,500, beep=True, reset=False)
    await motor.run_for_degrees(RIGHT_ATTACH,-90*deploy,600)
    await drive_straight(20,600, beep=True, reset=False)
    await motor.run_for_degrees(LEFT_ATTACH,int(60*40/24),600)
    await runloop.sleep_ms(500)
    await drive_straight(-70,1000, beep=True, reset=False)

async def action_black():
    print("Running BLACK function")

    # drive to angler
    motor.run(RIGHT_ATTACH,300)
    await drive_straight(82, 800)
    await pivot_turn(90,'r')
    await drive_straight(3, 300)
    await pivot_turn(10,'r')
    await motor.run_for_time(RIGHT_ATTACH, 3000, 700)
    await pid_turn(-10)

    #drive to bucket
    await drive_straight(-5,500)
    await pivot_turn(-45,'r',speed=150)
    await pivot_turn(45,'l',speed=150)
    await drive_straight(-10,500)

    #interact with
    await motor.run_for_degrees(LEFT_ATTACH,-100,500)

    #drive home
    await pivot_turn(-68,'l')
    await drive_straight(125,800)

async def action_blue():
    print("Running BLUE function")

    await drive_straight(37, 900)
    await motor.run_for_degrees(RIGHT_ATTACH, -640, 1000)
    await motor.run_for_degrees(LEFT_ATTACH, 130, 1000)
    await runloop.sleep_ms(1000)
    runloop.run(motor.run_for_degrees(RIGHT_ATTACH, 700, 1000), drive_straight(-24, 600))
    await drive_straight(7, 600)
    await pid_turn(-30)
    await drive_straight(-40, 1000)
    await pid_turn(-60)
    await drive_straight(20,1000)

async def action_green():
    print("Running GREEN function")
    leftRatio = 1.67
    rightRatio = 24/12*40/24
    leftLift = int(leftRatio*33)
    rightLift = int(83*rightRatio)*-1
    rightFlip = int(60*rightRatio)*-1
    motorSpeed = -200

    # drive from home and turn to minecart
    runloop.run(drive_straight(39.5*2.54,1000), motor.run_for_degrees(RIGHT_ATTACH,rightLift*2,500), motor.run_for_degrees(LEFT_ATTACH,int(180*leftRatio),500))
    await drive_straight(-1.75*2.54,400)
    await pivot_turn(-88, speed=200)
    runloop.run(motor.run_for_degrees(LEFT_ATTACH,int(200*leftRatio),-400, stop=motor.COAST), motor.run_for_degrees(RIGHT_ATTACH,-1*rightLift*2,500))
    await runloop.sleep_ms(500)
    # interact with minecart
    motor.reset_relative_position(LEFT_ATTACH, 0)
    await drive_straight(5.5*2.54,200)
    runloop.run(motor.run_for_degrees(RIGHT_ATTACH,rightLift,200),motor.run_to_relative_position(LEFT_ATTACH,leftLift,200, stop=motor.HOLD))
    await runloop.sleep_ms(500)
    runloop.run(motor.run_for_degrees(RIGHT_ATTACH,rightLift*-1,200), drive_straight(-5*2.54,300, reset=False))

    # navigate to seal
    runloop.run(pivot_turn(-39,'R',speed=150), motor.run_for_degrees(LEFT_ATTACH,180,700))
    await drive_straight(17*2.54,700)

    # interact with seal
    await pivot_turn(55,'R',speed=125, timeout=750)
    await motor.run_for_degrees(RIGHT_ATTACH,rightFlip,500)
    
    await pivot_turn(-30,'R', speed=300)

    # get home
    await drive_straight(-20,600)
    await pivot_turn(-100,'l')
    await drive_straight(20,700)
    await pivot_turn(55,'r')
    await drive_straight(47,1000)

async def action_red():
    print("Running RED function")

    # (12:24)(16:40)(40:20)(20:12)
    gearRatio = 12/24*16/40
    print(gearRatio)

    # 360 degrees = ~2 studs
    rotate = int(90/gearRatio)
    print(rotate)
    rate = 1000
    lift = 90
    motion_sensor.reset_yaw(0)
    yaw = 0
    turn = 30

    # sweeping
    # runloop.run(drive_straight(int(26*2.54),800, reset=False),motor.run_for_degrees(LEFT_ATTACH,-2*(rotate)+30,rate, stop=motor.HOLD))
    await drive_straight(int(26*2.54),800, reset=False)
    await drive_straight(int(-5.5*2.54),500)
    runloop.run(drive_straight(int(8*2.54),500), motor.run_for_degrees(LEFT_ATTACH,rotate,rate, stop=motor.HOLD), motor.run_for_degrees(RIGHT_ATTACH,int(lift),600))

    # deploy flag
    runloop.run(pivot_turn(40,'R', speed=200), motor.run_for_degrees(RIGHT_ATTACH,int(-1*lift),600))

    # interact with 3 plates
    await motor_pair.move_for_time(DRIVE_PAIR,1500,0, velocity=300)
    await motor.run_for_degrees(RIGHT_ATTACH,lift,500)
    await drive_straight(int(-4.75*2.54),400)

    # pick up fork
    await motor.run_for_degrees(LEFT_ATTACH,-1*(rotate+120),rate, stop=motor.HOLD)
    runloop.sleep_ms(1000)
    await motor.run_for_degrees(LEFT_ATTACH,rotate,int(rate/2), stop=motor.HOLD)

    # return home
    await pivot_turn(-50,'R')
    await drive_straight(-28*2.54,1000)

async def action_white():
    print("Running WHITE function")

    await drive_straight(72,700)
    await pid_turn(-90)
    await motor.run_for_degrees(LEFT_ATTACH, 90,1000)
    await runloop.sleep_ms(500)
    await drive_straight(10, 600)
    await drive_straight(-8,600)
    await pid_turn(70, kp=.9)
    await drive_straight(33,1000)
    await pid_turn(40, kp=.9)
    await drive_straight(65,1000)

async def action_yellow():
    print("Running YELLOW function")

    ratio = int(40/24)
    deploy = 160*ratio
    pause = 200
    i=0
    deployArm = 115

    await drive_straight(-3,300)
    await drive_straight(50,750)

    await motor.run_for_degrees(LEFT_ATTACH,deploy,1000)
    await runloop.sleep_ms(pause)
    await motor.run_for_degrees(LEFT_ATTACH,-1*(deploy),300)

    for i in range(3):
        await motor.run_for_degrees(LEFT_ATTACH,1*(deploy),1000)
        await runloop.sleep_ms(pause)
        await motor.run_for_degrees(LEFT_ATTACH,-1*(deploy),300)
        await runloop.sleep_ms(pause)

    runloop.sleep_ms(500)

    runloop.run(drive_straight(28,500), motor.run_for_degrees(RIGHT_ATTACH, -deployArm,500))
    await pivot_turn(90,'r', timeout=1500)

    await drive_straight(-7.5,500)
    await pivot_turn(135,"r")
    await drive_straight(60, 1000)

# --- Color lookup table (color -> (number, function)) ---
color_actions = {
    color.AZURE:    ('Az', action_azure),
    color.BLACK:    ('Ba', action_black),
    color.BLUE:    ('Bu', action_blue),
    color.GREEN:    ('Gr', action_green),
    color.RED:    ('Re', action_red),
    color.WHITE:    ('Wh', action_white),
    color.YELLOW:('Ye', action_yellow)
}

# --- Main loop ---
async def main():
    print("Ready... Press left or right button to choose action.")

    last_color = None

    while True:
        # Read current color
        current_color = color_sensor.color(COLOR_SENSOR)

        # If color changed, update the light matrix
        if current_color != last_color:
            if current_color in color_actions:
                num, _ = color_actions[current_color]
                light_matrix.write(str(num))
            else:
                light_matrix.write("?")
            last_color = current_color

        # Check for button press to run the action for the current color
        if button.pressed(button.LEFT) or button.pressed(button.RIGHT):
            if current_color in color_actions:
                _, func = color_actions[current_color]
                await func()
            else:
                print("No valid color detected")

            # Wait until buttons are released to avoid repeated triggers
            while button.pressed(button.LEFT) or button.pressed(button.RIGHT):
                await runloop.sleep_ms(50)

        await runloop.sleep_ms(50)# small delay to save CPU


runloop.run(main())
