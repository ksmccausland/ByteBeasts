import runloop, motor_pair, motor, color, color_sensor
from hub import light, motion_sensor, port, sound, button, light_matrix

WHEEL_DIAMETER = 6.24    # wheel diameter in CM (6.24cm)

# define drive motors and PAIR_1
LEFT_DRIVE = port.C
RIGHT_DRIVE = port.A
LEFT_ATTACH = port.B
RIGHT_ATTACH = port.F
COLOR_SENSOR = port.E

motor_pair.pair(motor_pair.PAIR_1, LEFT_DRIVE, RIGHT_DRIVE)
DRIVE_PAIR = motor_pair.PAIR_1

# Turn robot by amount target_angle in degrees via a PID (proportional, integral, derivative).You WILL need to adjust kp, ki, and kd for different robots
# based on your wheel choice, robot's weight, attachments, etc. max_speed and acceleration will limit robot drive parameters.
async def pid_turn(target_angle, *, max_speed=1000, acceleration=500, kp=.7, ki=0, kd=10, accuracy=3, beep=True, troubleshoot=False):
    # convert target angle to decidegrees
    target_angle = target_angle*10

    # wait until robot motion is stable - comment out if there is too much lag
    # await runloop.until(motion_sensor.stable)

    # Reset yaw to 0 before starting
    # motion_sensor.reset_yaw(0)

    integral = 0
    last_error = 0

    while True:
        # Current yaw angle
        current_angle = motion_sensor.tilt_angles()[0]# yaw in degrees
        error = target_angle - current_angle

        # Wrap error into [-1800, 1800]
        if error > 1800:
            error -= 3600
        elif error < -1800:
            error += 3600

        # Exit loop when robot angle is within accuracy
        if abs(error) < accuracy:
            break

        # PID correction calculation
        integral = integral + error
        derivative = error - last_error
        correction = kp * error + ki * integral + kd * derivative
        last_error = error

        # Clamp correction to max_speed
        correction = max(-max_speed, min(max_speed, correction))

        # Perform tank turn based on correction
        motor_pair.move_tank(DRIVE_PAIR, -int(correction), int(correction), acceleration=acceleration)

        # Print angle values to help troubleshoot
        if(troubleshoot == True):
            print(str(int(current_angle)) + " | " + str(int(target_angle)) + " | " + str(int(correction)))

        await runloop.sleep_ms(10)

    # Stop motors when loop is done
    motor_pair.stop(DRIVE_PAIR, stop=motor.SMART_BRAKE)

    # beep when function completes
    if(beep==True):
        sound.beep(1000)

# distance (cm), speed (deg/s). Positive distance = forward.
# accel/decel are distances (as a fraction of total) over which to ramp.
async def drive_straight(distance, speed, *, beep=True, accel=0.25, decel=0.25, end=motor.HOLD, reset=True):
    # direction/sign
    direction = -1 if distance >= 0 else 1
    max_speed = abs(int(speed))

    # convert cm -> wheel degrees
    target_degrees = abs(distance) * 360 / (WHEEL_DIAMETER * 3.14)
    accel_dist = target_degrees * max(0.0, min(0.9, accel))# clamp 0..0.9
    decel_dist = target_degrees * max(0.0, min(0.9, decel))

    # encoder & yaw reset
    motor.reset_relative_position(LEFT_DRIVE, 0)
    motor.reset_relative_position(RIGHT_DRIVE, 0)

    if reset == True:
        motion_sensor.reset_yaw(0)

    # wait until robot motion is stable (optional)
    # await runloop.until(motion_sensor.stable)

    def progress_deg():
        a = abs(motor.relative_position(LEFT_DRIVE))
        b = abs(motor.relative_position(RIGHT_DRIVE))
        return (a + b) / 2# <-- true average progress

    avg_deg = progress_deg()

    # give it some initial nudge to overcome static friction
    v_min = max(80, int(0.12 * max_speed))# 12% of max or 80 deg/s, whichever is higher

    while avg_deg < target_degrees:
        # heading correction from gyro (yaw)
        error = motion_sensor.tilt_angles()[0]
        correction = int(error * -2)

        remaining = max(0.0, target_degrees - avg_deg)

        # trapezoid profile factor in [0..1]
        accel_factor = 1.0 if accel_dist <= 1e-6 else (avg_deg / accel_dist)
        decel_factor = 1.0 if decel_dist <= 1e-6 else (remaining / decel_dist)
        shape = min(1.0, accel_factor, decel_factor)

        # target speed with floor (v_min)
        target_speed = int(v_min + (max_speed - v_min) * shape)

        # apply direction (Spike Prime uses positive=one direction; your code used -*)
        # Keep your sign convention: multiply by direction and -1 as before.
        cmd = target_speed * direction * -1

        motor_pair.move_tank(DRIVE_PAIR, cmd - correction, cmd + correction)

        # update progress
        avg_deg = progress_deg()

    motor_pair.stop(DRIVE_PAIR, stop=end)

    if beep:
        sound.beep(500)

# --- Define your functions for each color ---
async def action_azure():
    print("Running AZURE function")
    deploy = 15

    await drive_straight(64,1000, beep=True)
    await motor.run_for_degrees(RIGHT_ATTACH,90*deploy,1000)
    await runloop.sleep_ms(500)
    await drive_straight(-7,500, beep=True, reset=False)
    await motor.run_for_degrees(RIGHT_ATTACH,-90*deploy,1000)
    await drive_straight(20,700, beep=True, reset=False)
    await runloop.sleep_ms(200)
    await drive_straight(-70,1000, beep=True, reset=False)

async def action_blue():
    print("Running BLUE function")

    await drive_straight(40, 900)
    await motor.run_for_degrees(RIGHT_ATTACH, -700, 1000)
    await runloop.sleep_ms(500)
    await motor.run_for_degrees(LEFT_ATTACH, 120, 1000)
    await runloop.sleep_ms(1000)
    runloop.run(motor.run_for_degrees(RIGHT_ATTACH, 700, 1000), drive_straight(-20, 600))
    await drive_straight(10, 600)
    await pid_turn(-30)
    await drive_straight(-40, 1000)
    await pid_turn(-90)

async def action_green():
    print("Running GREEN function")
    deploy = 80
    lift = -45
    stow = deploy+lift
    
    await drive_straight(-80, 900)
    await pid_turn(-90)
    runloop.run(drive_straight(-16,500),motor.run_for_degrees(LEFT_ATTACH,deploy*13, 500)) 
    await pid_turn(90)
    await drive_straight(-14,500)
    await motor.run_for_degrees(LEFT_ATTACH,lift*13, 500)
    await runloop.sleep_ms(1000)
    await pid_turn(-25)
    runloop.run(drive_straight(90,1000), motor.run_for_degrees(LEFT_ATTACH,-stow*13, 500))

async def action_orange():
    print("Running ORANGE function")

async def action_red():
    print("Running RED function")
    deploy = -50

    await drive_straight(40,1000, beep=True)
    await drive_straight(10,400, beep=True, reset=False)
    await drive_straight(-10,400, beep=True, reset=False)
    await pid_turn(7)
    await drive_straight(10,300, beep=True)
    await runloop.sleep_ms (500)
    await motor.run_for_degrees(LEFT_ATTACH,deploy,600,stop=motor.HOLD)
    await drive_straight(-50,1000, beep=True)
    await motor.run_for_degrees(LEFT_ATTACH,-deploy,600,stop=motor.HOLD)

async def action_white():
    print("Running WHITE function")

    await drive_straight(72,700)
    await pid_turn(-90)
    await motor.run_for_degrees(LEFT_ATTACH, 90,1000)
    await runloop.sleep_ms(500)
    await drive_straight(10, 600)
    await drive_straight(-8,600)
    await pid_turn(70, kp=.9)
    await drive_straight(33,1000)
    await pid_turn(40, kp=.9)
    await drive_straight(65,1000)

async def action_yellow():
    print("Running YELLOW function")
    light_matrix.show_image(light_matrix.IMAGE_GIRAFFE)
    ratio = int(40/24)
    deploy = 160*ratio
    pause = 500
    i=0
    deployArm = 180

    
    await motor.run_for_degrees(LEFT_ATTACH,deploy,1000)
    await runloop.sleep_ms(pause)
    await motor.run_for_degrees(LEFT_ATTACH,-1*(deploy),200)

    for i in range(3):
        await motor.run_for_degrees(LEFT_ATTACH,1*(deploy),1000)
        await runloop.sleep_ms(pause)
        await motor.run_for_degrees(LEFT_ATTACH,-1*(deploy),200)
        await runloop.sleep_ms(pause)

    runloop.run(drive_straight(5,300), motor.run_for_degrees(RIGHT_ATTACH, -deployArm,500))
    await runloop.sleep_ms(1000)
    await motor.run_for_degrees(RIGHT_ATTACH, deployArm,500)

# --- Color lookup table (color -> (number, function)) ---
color_actions = {
    color.AZURE:    ('Az', action_azure),
    color.BLUE:     ('Bl', action_blue),
    color.GREEN:    ('Gr', action_green),
    color.RED:      ('Re', action_red),
    color.WHITE:    ('Wh', action_white),
    color.YELLOW:   ('Ye', action_yellow)
}

# --- Main loop ---
async def main():
    print("Ready... Press left or right button to choose action.")

    last_color = None

    while True:
        # Read current color
        current_color = color_sensor.color(COLOR_SENSOR)
        print(color_sensor.color(COLOR_SENSOR))

        # If color changed, update the light matrix
        if current_color != last_color:
            if current_color in color_actions:
                num, _ = color_actions[current_color]
                light_matrix.write(str(num))
            else:
                light_matrix.write("?")
            last_color = current_color

        # Check for button press to run the action for the current color
        if button.pressed(button.LEFT) or button.pressed(button.RIGHT):
            if current_color in color_actions:
                _, func = color_actions[current_color]
                await func()
            else:
                print("No valid color detected")

            # Wait until buttons are released to avoid repeated triggers
            while button.pressed(button.LEFT) or button.pressed(button.RIGHT):
                await runloop.sleep_ms(50)

        await runloop.sleep_ms(50)# small delay to save CPU


runloop.run(main())
